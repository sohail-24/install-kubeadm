# Kubernetes Cluster Setup using kubeadm (Master & Worker)

This repository provides **automated shell scripts** to set up a **Kubernetes cluster using kubeadm** on Ubuntu systems.

The setup follows **official Kubernetes best practices**, using:

* **containerd** as the Kubernetes container runtime
* **Docker** for developer convenience (image building, debugging, CI/CD)

---

## üìå Prerequisites

* Ubuntu 20.04 / 22.04
* Minimum 2 CPUs (Master)
* At least 2 GB RAM (4 GB recommended for Master)
* Passwordless `sudo` access
* Internet connectivity

---

## üß± Architecture

* **1 Master Node**
* **1 or more Worker Nodes**
* Runtime: **containerd**
* Kubernetes version: **v1.29**

---

## üöÄ Master Node Setup

Run the following commands **on the Master node**:

```bash


chmod +x k8s-master.sh
sudo ./k8s-master.sh

```

### Initialize the Kubernetes control plane:

```bash

kubeadm init

```

> Save the `kubeadm join` command printed at the end ‚Äî it is required for worker nodes.

---

## üöÄ Worker Node Setup

Run the following commands **on each Worker node**:

```bash

chmod +x k8s-worker.sh
sudo ./k8s-worker.sh
```

### Join the worker node to the cluster:

```bash
kubeadm join <MASTER-IP>:6443 --token <TOKEN> --discovery-token-ca-cert-hash sha256:<HASH>
```

---

## üê≥ Why Docker is Installed?

Kubernetes **does NOT require Docker** as a runtime anymore.

* Kubernetes uses **containerd**
* Docker is installed **only for**:

  * Image building
  * Debugging containers
  * CI/CD workflows
  * Developer convenience

This follows **modern Kubernetes standards**.

---

## üîê Security & Best Practices

* Swap disabled (mandatory for Kubernetes)
* Required kernel modules loaded
* Proper sysctl configuration
* Kubernetes components version locked
* Services enabled on boot

---

## üìå Next Recommended Steps

After cluster setup:

* Install a **CNI plugin** (e.g., Calico)
* Configure `kubectl` for non-root user
* Add monitoring (Prometheus + Grafana)
* Enable HPA and NetworkPolicies

---

## ‚úÖ Summary

‚úî Fully automated installation
‚úî Separate Master & Worker scripts
‚úî Production & interview ready
‚úî Clean and reusable for real projects

---

Happy Kubernetes Learning ‚ò∏Ô∏è
**Built with a DevOps Engineer mindset**

‚úÖ STEP 1 ‚Äî Initialize Control Plane (MASTER)

kubeadm init \
  --pod-network-cidr=192.168.0.0/16 \
  --apiserver-cert-extra-sans=$(hostname -I | awk '{print $1}')


Configure kubectl:

mkdir -p ~/.kube
sudo cp /etc/kubernetes/admin.conf ~/.kube/config
sudo chown $(id -u):$(id -g) ~/.kube/config

‚úÖ STEP 2 ‚Äî Install CNI (Calico)

kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.27.3/manifests/calico.yaml

Wait:

kubectl get pods -n kube-system

‚úÖ STEP 3 ‚Äî Join Worker Node(s)

On MASTER:

kubeadm token create --print-join-command

On WORKER:

sudo kubeadm join <MASTER-IP>:6443 --token <TOKEN> \
--discovery-token-ca-cert-hash sha256:<HASH>

Verify:

kubectl get nodes

‚úÖ STEP 4 ‚Äî Workload Validation

kubectl create deployment nginx --image=nginx
kubectl scale deployment nginx --replicas=2
kubectl get pods

‚úÖ STEP 5 ‚Äî Metrics Server

kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml

kubectl patch deployment metrics-server -n kube-system \
  --type=json -p='[
    {"op":"add","path":"/spec/template/spec/containers/0/args/-","value":"--kubelet-insecure-tls"}
  ]'

wait 2 min

kubectl get apiservices | grep metrics

Verify:

kubectl top nodes
kubectl top pods

‚úÖ STEP 6 ‚Äî HPA

kubectl set resources deployment nginx \
  --requests=cpu=100m --limits=cpu=200m

kubectl autoscale deployment nginx \
  --cpu-percent=50 --min=1 --max=5

kubectl get hpa


‚úÖ STEP 7 ‚Äî PodDisruptionBudget

vi nginx-pdb.yaml

apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: nginx-pdb
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: nginx


kubectl apply -f nginx-pdb.yaml
kubectl get pdb

‚úÖ STEP 8 ‚Äî ClusterIP (Internal Service)

kubectl expose deployment nginx \
  --name=nginx-clusterip \
  --port=80 \
  --target-port=80 \
  --type=ClusterIP

Test:

kubectl run test --rm -it --image=busybox -- /bin/sh

wget -qO- http://nginx-clusterip.default.svc.cluster.local

‚úÖ STEP 9 ‚Äî NetworkPolicies (Zero Trust)

vi nginx-default-deny.yaml

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: nginx-default-deny
spec:
  podSelector:
    matchLabels:
      app: nginx
  policyTypes:
  - Ingress


kubectl apply -f nginx-default-deny.yaml


9.2 Allow traffic ONLY from Ingress Controller

vi nginx-allow-ingress.yaml


apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: nginx-allow-from-ingress
spec:
  podSelector:
    matchLabels:
      app: nginx
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: ingress-nginx
    ports:
    - protocol: TCP
      port: 80


kubectl apply -f nginx-allow-ingress.yaml


Verify:

kubectl get networkpolicy

‚úÖ STEP 10 ‚Äî Load Balancer (NGINX Ingress Controller ‚Äì kubeadm PRO way)

kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/baremetal/deploy.yaml


Wait:

kubectl get pods -n ingress-nginx


10.2 Verify Ingress Controller service

kubectl get svc -n ingress-nginx

10.3 Create Ingress rules (Routing)

vi nginx-ingress.yaml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-ingress
spec:
  ingressClassName: nginx
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-clusterip
            port:
              number: 80


kubectl apply -f nginx-ingress.yaml

Verify:

kubectl get ingress
kubectl describe ingress nginx-ingress

‚úÖ STEP 8 ‚Äî NetworkPolicies (Zero Trust)

vi nginx-default-deny.yaml

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: nginx-default-deny
spec:
  podSelector:
    matchLabels:
      app: nginx
  policyTypes:
  - Ingress

kubectl apply -f nginx-default-deny.yaml

vi nginx-allow-ingress.yaml

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: nginx-allow-from-ingress
spec:
  podSelector:
    matchLabels:
      app: nginx
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: ingress-nginx
    ports:
    - protocol: TCP
      port: 80

kubectl apply -f nginx-allow-ingress.yaml

Verify

kubectl get networkpolicy

‚úÖ STEP 9 ‚Äî Ingress Controller (NGINX)

kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/baremetal/deploy.yaml

Wait

kubectl get pods -n ingress-nginx

Verify Ingress Controller Service

kubectl get svc -n ingress-nginx

‚úÖ STEP 10 ‚Äî Load Balancer (Ingress Routing)

kubectl expose deployment nginx \
  --name=nginx-clusterip \
  --port=80 \
  --target-port=80 \
  --type=ClusterIP

Test internally


kubectl run test --rm -it --image=busybox -- /bin/sh

wget -qO- http://nginx-clusterip.default.svc.cluster.local

10.2 Create Ingress Rules (Routing)

vi nginx-ingress.yaml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-ingress
spec:
  ingressClassName: nginx
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-clusterip
            port:
              number: 80


kubectl apply -f nginx-ingress.yaml

kubectl get ingress
kubectl describe ingress nginx-ingress

Access Application (Browser)

http://<NODE_PUBLIC_IP>:<INGRESS_NODEPORT>

‚úÖ STEP 11 ‚Äî Frontend Deployment (React + Ingress)


docker build -t sohail28/react-frontend:v1 .
docker push sohail28/react-frontend:v1

Deploy Frontend

vi react-deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: react-frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: react
  template:
    metadata:
      labels:
        app: react
    spec:
      containers:
      - name: react
        image: sohail28/react-frontend:v1
        ports:
        - containerPort: 80

kubectl apply -f react-deployment.yaml

vi react-service.yaml

apiVersion: v1
kind: Service
metadata:
  name: react-clusterip
spec:
  type: ClusterIP
  selector:
    app: react
  ports:
  - port: 80
    targetPort: 80

kubectl apply -f react-service.yaml

Create Ingress for Frontend

vi react-ingress.yaml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: react-ingress
spec:
  ingressClassName: nginx
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: react-clusterip
            port:
              number: 80

kubectl apply -f react-ingress.yaml


kubectl get pods
kubectl get svc
kubectl get ingress













