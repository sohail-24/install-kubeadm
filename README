# Kubernetes Cluster Setup using kubeadm (Master & Worker)

This repository provides **automated shell scripts** to set up a **Kubernetes cluster using kubeadm** on Ubuntu systems.

The setup follows **official Kubernetes best practices**, using:

* **containerd** as the Kubernetes container runtime
* **Docker** for developer convenience (image building, debugging, CI/CD)

---

## ðŸ“Œ Prerequisites

* Ubuntu 20.04 / 22.04
* Minimum 2 CPUs (Master)
* At least 2 GB RAM (4 GB recommended for Master)
* Passwordless `sudo` access
* Internet connectivity

---

## ðŸ§± Architecture

* **1 Master Node**
* **1 or more Worker Nodes**
* Runtime: **containerd**
* Kubernetes version: **v1.29**

---



---

## ðŸ³ Why Docker is Installed?

Kubernetes **does NOT require Docker** as a runtime anymore.

* Kubernetes uses **containerd**
* Docker is installed **only for**:

  * Image building
  * Debugging containers
  * CI/CD workflows
  * Developer convenience

This follows **modern Kubernetes standards**.

---

## ðŸ” Security & Best Practices

* Swap disabled (mandatory for Kubernetes)
* Required kernel modules loaded
* Proper sysctl configuration
* Kubernetes components version locked
* Services enabled on boot

---

## ðŸ“Œ Next Recommended Steps

After cluster setup:

* Install a **CNI plugin** (e.g., Calico)
* Configure `kubectl` for non-root user
* Add monitoring (Prometheus + Grafana)
* Enable HPA and NetworkPolicies

---

## âœ… Summary

âœ” Fully automated installation
âœ” Separate Master & Worker scripts
âœ” Production & interview ready
âœ” Clean and reusable for real projects

---

Happy Kubernetes Learning â˜¸ï¸
**Built with a DevOps Engineer mindset**
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>













## ðŸš€ Master Node Setup

chmod +x k8s-master.sh
sudo ./k8s-master.sh

## ðŸš€ Worker Node Setup

chmod +x k8s-worker.sh
sudo ./k8s-worker.sh

On Master:

kubectl get pods -n kube-system

âœ… STEP 3 â€” Join Worker Node(s)

On MASTER:

kubeadm token create --print-join-command

On WORKER:

sudo kubeadm join <MASTER-IP>:6443 --token <TOKEN> \
--discovery-token-ca-cert-hash sha256:<HASH>

Verify:

kubectl get nodes

âœ… STEP 4 â€” Workload Validation

kubectl create deployment nginx --image=nginx
kubectl scale deployment nginx --replicas=2
kubectl get pods

âœ… STEP 5 â€” Metrics Server

kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml

kubectl patch deployment metrics-server -n kube-system \
  --type=json -p='[
    {"op":"add","path":"/spec/template/spec/containers/0/args/-","value":"--kubelet-insecure-tls"}
  ]'



kubectl edit deployment metrics-server -n kube-system

args:
- --cert-dir=/tmp
- --secure-port=4443
- --kubelet-insecure-tls
- --kubelet-preferred-address-types=InternalIP

ports:
- containerPort: 4443


kubectl edit svc metrics-server -n kube-system

edit ---> targetPort: 4443

kubectl rollout restart deployment metrics-server -n kube-system


Verify: wait 2 min

kubectl get pods -n kube-system | grep metrics

kubectl get apiservices | grep metrics

kubectl top nodes
kubectl top pods

âœ… STEP 6 â€” HPA

kubectl set resources deployment nginx \
  --requests=cpu=100m --limits=cpu=200m

kubectl autoscale deployment nginx \
  --cpu-percent=50 --min=1 --max=5

kubectl get hpa


âœ… STEP 7 â€” PodDisruptionBudget

vi nginx-pdb.yaml

apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: nginx-pdb
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: nginx


kubectl apply -f nginx-pdb.yaml
kubectl get pdb

âœ… STEP 8 â€” ClusterIP (Internal Service)

kubectl expose deployment nginx \
  --name=nginx-clusterip \
  --port=80 \
  --target-port=80 \
  --type=ClusterIP


Test:

kubectl run test --rm -it --image=busybox -- /bin/sh

wget -qO- http://nginx-clusterip.default.svc.cluster.local


âœ… STEP 9 â€” NetworkPolicies (Zero Trust)

vi nginx-default-deny.yaml

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: nginx-default-deny
spec:
  podSelector:
    matchLabels:
      app: nginx
  policyTypes:
  - Ingress


kubectl apply -f nginx-default-deny.yaml


9.2 Allow traffic ONLY from Ingress Controller

vi nginx-allow-ingress.yaml


apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: nginx-allow-from-ingress
spec:
  podSelector:
    matchLabels:
      app: nginx
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: ingress-nginx
    ports:
    - protocol: TCP
      port: 80


kubectl apply -f nginx-allow-ingress.yaml


Verify:

kubectl get networkpolicy

âœ… STEP 10 â€” Load Balancer (NGINX Ingress Controller â€“ kubeadm PRO way)

kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/baremetal/deploy.yaml



Wait:

kubectl get pods -n ingress-nginx


10.2 Verify Ingress Controller service

kubectl get svc -n ingress-nginx

10.3 Create Ingress rules (Routing)

vi nginx-ingress.yaml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-ingress
spec:
  ingressClassName: nginx
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-clusterip
            port:
              number: 80


kubectl apply -f nginx-ingress.yaml

Verify:

kubectl get ingress
kubectl describe ingress nginx-ingress




Access Application (Browser)

http://<NODE_PUBLIC_IP>:<INGRESS_NODEPORT>

âœ… STEP 11 â€” Frontend Deployment (React + Ingress)


docker build -t sohail28/react-frontend:v1 .
docker push sohail28/react-frontend:v1

Deploy Frontend

vi react-deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: react-frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: react
  template:
    metadata:
      labels:
        app: react
    spec:
      containers:
      - name: react
        image: sohail28/react-frontend:v1
        ports:
        - containerPort: 80

kubectl apply -f react-deployment.yaml

vi react-service.yaml

apiVersion: v1
kind: Service
metadata:
  name: react-clusterip
spec:
  type: ClusterIP
  selector:
    app: react
  ports:
  - port: 80
    targetPort: 80

kubectl apply -f react-service.yaml

Create Ingress for Frontend

vi react-ingress.yaml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: react-ingress
spec:
  ingressClassName: nginx
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: react-clusterip
            port:
              number: 80

kubectl apply -f react-ingress.yaml


kubectl get pods
kubectl get svc
kubectl get ingress













